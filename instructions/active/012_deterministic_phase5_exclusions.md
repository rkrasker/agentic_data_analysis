# 012: Deterministic Phase 5 Exclusions

**Status:** active
**Created:** 2026-01-29
**Component:** src/strategies/resolver/generator/

## Context

ADR-009 Decision 3 specifies that Phase 5 (exclusion mining) should become a deterministic computation with no LLM calls. The rationale: with synthetic data where hierarchy is complete by construction, "Regiment 11 isn't in 1st ID" is a structural fact derivable from `hierarchy_reference.json`—mining this from data via LLM is backwards.

Currently, `llm_phases.py::mine_exclusions()` has two sub-phases:
- **structural**: Derived from hierarchy (keep this)
- **value_based**: Mined from data via LLM (remove this)

The `structural_discriminators.json` file (generated by `src/preprocessing/hierarchy/structural_discriminators.py`) already contains the precomputed collision index and branch exclusion rules needed for deterministic exclusions.

## Task

Replace the Phase 5 LLM call with deterministic exclusion computation using precomputed structural discriminators.

## Scope

- **Working in:** `src/strategies/resolver/generator/`
- **Reference:** `docs/architecture/decisions/ADR-009_resolver-generation-alignment.md`
- **Config inputs:** `config/hierarchies/structural_discriminators.json`, `config/hierarchies/hierarchy_reference.json`
- **Test location:** `tests/strategies/resolver/generator/`
- **Ignore:** `.project_history/`, LLM phases 4/6/7/8, sampling logic

## Inputs

| File | Purpose |
|------|---------|
| `config/hierarchies/structural_discriminators.json` | Precomputed collision index, branch exclusion rules |
| `config/hierarchies/hierarchy_reference.json` | Full hierarchy structure for validation |
| `ComponentStructure` from structure.py | Per-component structural data |

## Outputs

| Change | Description |
|--------|-------------|
| `ExclusionResult` | Same dataclass, but `value_based` always empty, `value_based_status` = "not_applicable" |
| Resolver JSON | No `value_based` section in `exclusions`; simplified schema |

### New Exclusions Schema

```json
{
  "exclusions": {
    "status": "complete",
    "source": "hierarchy_derived",
    "rules": [
      {"if_contains": "squadron", "then": "exclude", "reason": "term unique to defense_command"},
      {"if_depth": 5, "then": "exclude", "reason": "branch depth is 4"},
      {"if_invalid_designator": "fleet_8", "then": "exclude", "reason": "designator does not exist"}
    ]
  }
}
```

## Implementation Steps

### Step 1: Add exclusion loader to structure.py

Create a function to load and parse structural_discriminators.json:

```python
def load_structural_discriminators(path: Path = None) -> dict:
    """Load precomputed structural discriminators from JSON.

    Returns dict with keys:
    - collision_index: Dict[Tuple[level, value], Set[component_id]]
    - branch_exclusion_rules: List[Dict] with if_contains/implies_branch
    - depth_by_branch: Dict[branch, int]
    """
```

### Step 2: Create compute_exclusions() function

Add to `structure.py`:

```python
def compute_exclusions(
    component_id: str,
    structure: ComponentStructure,
    structural_discriminators: dict,
    hierarchy: dict,
) -> List[Dict]:
    """
    Derive exclusion rules deterministically from hierarchy.
    No LLM required.

    Returns list of exclusion rules:
    - Branch-unique terms (from structural_discriminators)
    - Depth mismatches
    - Invalid designators for this component
    """
```

The function should:
1. Get this component's branch from hierarchy
2. Find terms that are unique to OTHER branches (from `branch_exclusion_rules`)
3. Find depth mismatches (if this branch has depth N, paths of depth != N exclude)
4. Find invalid designators (designators valid elsewhere but not here)

### Step 3: Update mine_exclusions() in llm_phases.py

Replace the current implementation:

```python
def mine_exclusions(
    component_id: str,
    component_name: str,
    structure: ComponentStructure,
    all_structures: Dict[str, ComponentStructure],
    component_samples: ComponentSamples,  # No longer used for LLM mining
    llm: BaseLLMProvider,  # No longer used
    tier: TierName,
    structural_discriminators: dict,  # NEW parameter
    hierarchy: dict,  # NEW parameter
) -> ExclusionResult:
    """
    Phase 5: Compute exclusion rules deterministically.

    NO LLM CALL. All rules derived from hierarchy structure.
    """
    # Structural exclusions (existing logic - keep)
    structural = get_structural_exclusions(component_id, structure, all_structures)

    # Deterministic exclusions (replaces LLM-mined value_based)
    deterministic = compute_exclusions(
        component_id, structure, structural_discriminators, hierarchy
    )

    # Merge structural + deterministic into unified rules list
    all_rules = structural + deterministic

    return ExclusionResult(
        structural=all_rules,
        value_based=[],  # Always empty now
        structural_status="complete",
        value_based_status="not_applicable"  # Changed from "complete"
    )
```

### Step 4: Update callers of mine_exclusions()

In `llm_phases.py` or `generate.py`, update the call site to pass the new parameters:

```python
# Load once at start of generation
structural_discriminators = load_structural_discriminators()
hierarchy = load_hierarchy_reference()

# Pass to mine_exclusions
exclusions = mine_exclusions(
    component_id=component_id,
    component_name=component_name,
    structure=structure,
    all_structures=all_structures,
    component_samples=samples,  # Can remove if not needed elsewhere
    llm=llm,  # Can remove if not needed elsewhere
    tier=tier,
    structural_discriminators=structural_discriminators,
    hierarchy=hierarchy,
)
```

### Step 5: Update assembler.py schema

In `_build_exclusions_section()`:

```python
def _build_exclusions_section(exclusion_result: ExclusionResult) -> dict:
    """Build exclusions section for resolver JSON.

    New schema (ADR-009): No value_based section.
    """
    return {
        "status": exclusion_result.structural_status,
        "source": "hierarchy_derived",
        "rules": exclusion_result.structural  # All rules in one list
    }
```

Remove any code that outputs `value_based` section.

### Step 6: Remove or deprecate tier_allows_value_exclusions()

In `thresholds.py`, either:
- Remove `tier_allows_value_exclusions()` entirely, OR
- Have it always return `False` with a deprecation comment

### Step 7: Clean up prompts.py

Remove `build_exclusion_mining_prompt()` and any related prompt templates for value-based exclusion mining.

## Acceptance Criteria

- [ ] `mine_exclusions()` makes NO LLM calls
- [ ] `structural_discriminators.json` is loaded and used for exclusion computation
- [ ] `ExclusionResult.value_based` is always empty list
- [ ] `ExclusionResult.value_based_status` is "not_applicable"
- [ ] Resolver JSON has no `value_based` section in exclusions
- [ ] Resolver JSON exclusions include branch-unique term rules
- [ ] Resolver JSON exclusions include depth mismatch rules where applicable
- [ ] Existing structural exclusions (service branch, component type) still work
- [ ] Tests pass in `tests/strategies/resolver/generator/`
- [ ] No regressions in resolver generation for existing components

## Notes

### Code Style

Follow `docs/CODE_STYLE.md`:
- `compute_exclusions()` should be a pure function, not a class method
- No factory patterns for loading discriminators
- Return `List[Dict]` directly, not a custom container class

### Backward Compatibility

- The `llm` and `component_samples` parameters can be kept for now (ignored) to avoid breaking callers
- Or remove them if you update all call sites—your choice based on scope
- Existing resolvers in `config/resolvers/` will have the old schema; they don't need migration (regenerate when needed)

### What "Deterministic" Means

The exclusion rules are derived from:
1. **Branch-unique terms**: If "squadron" only appears in Defense Command, any record containing "squadron" excludes all other branches
2. **Depth constraints**: If this component's branch has depth 4, a 5-level path excludes it
3. **Invalid designators**: If Fleet 8 doesn't exist in this branch, its presence excludes

These are ALL derivable from hierarchy_reference.json + structural_discriminators.json. No LLM judgment needed.

### Edge Cases

- Component in a branch with no unique terms: Only depth + invalid designator rules apply
- Component at unusual depth: Ensure depth comparison works for variable-depth branches
- Missing structural_discriminators.json: Fail loudly with clear error, don't fall back to empty rules

## References

- ADR-009: `docs/architecture/decisions/ADR-009_resolver-generation-alignment.md` (Decision 3)
- Structural discriminators: `src/preprocessing/hierarchy/structural_discriminators.py`
- Current Phase 5: `src/strategies/resolver/generator/llm_phases.py` lines 493-582
- Hierarchy reference: `config/hierarchies/hierarchy_reference.json`
