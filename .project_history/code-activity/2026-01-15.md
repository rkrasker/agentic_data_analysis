# Code Activity Log: 2026-01-15

**Session:** Claude Code (Opus 4.5)
**Focus:** Resolver generation workflow design and documentation

---

## Summary

Design session for resolver generation workflow. Established that resolver generation is a component-centric build-time workflow (not a parallel routing pipeline). Designed relative threshold system for tiered generation based on validation data distribution. Updated documentation with full implementation plan.

---

## Files Created

| File | Purpose |
|------|---------|
| `.project_history/extracts/raw/2026-01-15_opus_resolver-generation-design.md` | Thread extract for this session |

## Files Modified

| File | Changes |
|------|---------|
| `docs/components/strategies/resolver/CURRENT.md` | Complete rewrite with implementation plan |
| `docs/data-structures/CURRENT.md` | Added resolver_registry.json, train_test_split.json, updated resolver schema |
| `docs/architecture/CURRENT.md` | Updated strategies table, added resolver generation to next steps |
| `docs/components/strategies/_comparison/CURRENT.md` | Updated resolver status to "Detailed design" |

---

## Design Work (No Code Implementation)

### 1. Resolver Generation Conceptual Model

Clarified that resolver generation is NOT a parallel routing pipeline:
- Validation data already has ground truth component assignments
- No routing needed — group by known component
- Information flow is inverted from main pipeline

### 2. Relative Threshold System

Designed tier calculation from validation distribution:
```python
well_represented:        count >= p75
adequately_represented:  count >= median
under_represented:       count >= p25
sparse:                  count < p25
```

### 3. Tiered Generation Rules

Defined what gets generated at each tier:
- **sparse:** hierarchy-only (structure + structural exclusions)
- **under_represented:** limited patterns, no vocabulary
- **adequately_represented:** full generation, vocabulary may be thin
- **well_represented:** full generation

### 4. Asymmetric Rival Handling

- Strong component can use weak rival in differentiators (flag as `rival_undersampled`)
- Weak component gets hierarchy-only resolver with quality warnings

### 5. Registry Design

`resolver_registry.json` tracks:
- Tier and sample size per component
- Section-level completeness
- Rebuild triggers (conditions for regeneration)
- Quality notes

---

## New Data Structures Defined

### resolver_registry.json

Tracks all resolver generation status with rebuild triggers:
```json
{
  "meta": {"thresholds": {"p25": N, "median": N, "p75": N}},
  "resolvers": {
    "{component}": {
      "tier": "...",
      "sections": {...},
      "rebuild_triggers": [...]
    }
  },
  "summary": {...}
}
```

### train_test_split.json

Records train/test split for reproducibility:
```json
{
  "meta": {"split_ratio": {"train": 0.75, "test": 0.25}},
  "splits": {
    "{component}": {
      "train_ids": [...],
      "test_ids": [...],
      "by_stratum": {...}
    }
  }
}
```

### Updated resolver schema

Added to {component}_resolver.json:
- `meta.tier`, `meta.generation_mode`, `meta.pct_of_median`
- `status` field on each section
- `quality_notes` array

---

## Implementation Path Defined

```
src/strategies/resolver/generator/
├── thresholds.py      # Tier calculation
├── split.py           # Train/test split
├── structure.py       # Phase 1-2
├── sampling.py        # Phase 3
├── llm_phases.py      # Phase 4-8
└── registry.py        # Registry management
```

---

## Key Decisions

1. No parallel routing pipeline — resolver gen uses ground truth
2. Relative thresholds based on percentiles of actual distribution
3. Graceful degradation for sparse components
4. Asymmetric rival handling in differentiators
5. Registry-based rebuild tracking

---

## Open Questions

- Exact percentile thresholds (p25/median/p75) vs alternatives?
- Minimum per-collision-pair sample size?
- LLM model selection for generation phases?

---

## Next Steps

1. Implement threshold calculator
2. Implement train/test splitter with stratification
3. Implement Phase 1-2 (structure extraction, collision detection)
4. Implement Phase 3 (collision sampling)
5. Implement Phase 4-8 (LLM-driven phases)
