# Session Extract: Resolver ADR-009 Completion Planning

**Date:** 2026-01-29
**Model:** Opus 4.5
**Topic:** Planning remaining ADR-009 implementation work

## Summary

Analyzed the resolver generation pipeline to determine what remains for full ADR-009 compliance. Created three implementation instructions (012-014) for Sonnet execution.

## Key Findings

### What's Already Done (Instructions 009-011)

| ADR-009 Decision | Implementation |
|------------------|----------------|
| Decision 1: Sample by Soldier Difficulty | ✅ `compute_soldier_difficulty()` in src/preprocessing/difficulty/ |
| Decision 1: Stratified sampling | ✅ `_stratified_sample()` in sampling.py with tier weights |
| Decision 1: Train/test split with difficulty | ✅ `prepare_train_split.py` outputs train_with_difficulty.parquet |

### What Remains (Instructions 012-014)

| ADR-009 Decision | Gap | Instruction |
|------------------|-----|-------------|
| Decision 2: Branch-aware structure | structure.py assumes uniform Division→Regiment→Battalion→Company | 013 |
| Decision 3: Deterministic Phase 5 | `mine_exclusions()` still has LLM call for value_based rules | 012 |
| Decision 4: Three-layer hard cases | prompts.py uses symptomatic criteria, includes "transfer indicators" | 014 |

## Decisions Made

### Instruction Ordering

Recommended order: **012 → 014 → 013**

Rationale:
- 012 (Phase 5) is smallest scope and cleanest to implement
- 014 (hard cases) is independent and can follow immediately
- 013 (structure rewrite) is largest and most invasive—do last

### Quality Tier Filtering

The exploration revealed `_filter_records_by_quality()` in llm_phases.py. This function:
- Filters records by quality tier (prefers tiers 3-5)
- Used in pattern discovery and exclusion mining

**Decision:** This should be removed as part of ADR-009 Decision 1 compliance, but it's already partially addressed by the stratified sampling work. The remaining filtering in LLM phases can be addressed in a follow-up cleanup or as part of 012/013.

**Noted but not included in instructions** to keep scope focused.

### Structural Discriminators Integration

`structural_discriminators.json` is already generated by preprocessing but NOT consumed by resolver generation. Instructions 012 and 013 both wire this up:
- 012: Uses it for deterministic exclusion rules
- 013: Uses it for branch-unique terms in ComponentStructure

## Alternatives Considered

### Option A: Single Large Instruction
Considered combining all remaining work into one instruction.

**Rejected because:**
- Too large for single Sonnet session
- Testing becomes unwieldy
- Partial progress can't be committed

### Option B: Start with Structure Rewrite (013)
Considered doing the largest change first.

**Rejected because:**
- Phase 5 and hard cases don't strictly depend on new structure
- Smaller wins first builds momentum
- structure.py changes ripple through more code

### Option C: Remove Quality Filtering in Separate Instruction
Considered a dedicated instruction to remove `_filter_records_by_quality()`.

**Rejected because:**
- It's partially obsoleted by stratified sampling
- Can be done opportunistically during 012/013
- Low priority—doesn't block anything

## Implications for Implementation

### Dependency Chain

```
012 (Phase 5 Deterministic)
    ├── Needs: structural_discriminators.json (exists)
    └── Produces: Simplified exclusions schema

013 (Branch-Aware Structure)
    ├── Needs: hierarchy_reference.json (exists), structural_discriminators.json (exists)
    ├── Produces: New ComponentStructure schema
    └── Changes: assembler.py output format

014 (Three-Layer Hard Cases)
    ├── Needs: Nothing (prompt/schema change only)
    └── Produces: Layer-tagged hard cases
```

012 and 014 are independent. 013 can benefit from 012 being done first (shared discriminators loading logic).

### Testing Considerations

Each instruction specifies test requirements. Key points:
- Use fixtures, not full hierarchy files
- Mock LLM responses where needed
- Verify backward compatibility during transition

### Backward Compatibility

Old resolvers in `config/resolvers/` won't match new schema. This is fine:
- Resolvers are regenerated on demand
- No migration script needed
- Old schema just becomes outdated

## Warnings and Pitfalls

### 1. hierarchy_reference.json Format Uncertainty

The instructions assume a specific format for hierarchy_reference.json. Before implementing 013, **inspect the actual file** to confirm structure. The pseudocode may need adjustment.

### 2. Prompt Compliance for Hard Cases

LLMs may not always return the `layer` field in hard case output. Instruction 014 includes graceful fallback to `"unknown"`, but this should be monitored.

### 3. Structural Discriminators May Be Incomplete

The generated `structural_discriminators.json` was created for preprocessing purposes. Verify it has:
- `collision_index` (for 012)
- `branch_exclusion_rules` (for 012, 013)
- `depth_by_branch` or equivalent (for 013)

If missing keys, may need to update the generator first.

### 4. Ripple Effects from ComponentStructure Change

Instruction 013 changes the `ComponentStructure` dataclass significantly. Any code that accesses `.valid_regiments`, `.valid_battalions`, `.valid_companies` will break.

Search for these usages before implementing:
```
grep -r "valid_regiments\|valid_battalions\|valid_companies" src/
```

## Open Questions

1. **Should `_filter_records_by_quality()` be explicitly removed?**
   Currently not in scope. May be dead code after stratified sampling is fully wired.

2. **Do prompts in other phases reference regiment/battalion/company?**
   If so, they may need updates after 013. Not included in 014 scope.

3. **Should resolver JSON include full hard case details or just counts?**
   Currently instructions say counts + by-layer breakdown. Full details could bloat output.

## Artifacts Produced

| Artifact | Location |
|----------|----------|
| Instruction 012 | `instructions/active/012_deterministic_phase5_exclusions.md` |
| Instruction 013 | `instructions/active/013_branch_aware_structure.md` |
| Instruction 014 | `instructions/active/014_three_layer_hard_cases.md` |
| This extract | `.project_history/extracts/raw/2026-01-29_opus_resolver-adr009-completion.md` |

## Next Steps

1. Implement Instruction 012 (Sonnet)
2. Implement Instruction 014 (Sonnet, can parallel with 012 if desired)
3. Implement Instruction 013 (Sonnet, after 012 complete)
4. Verify full resolver generation with new pipeline
5. Regenerate sample resolvers and validate output schema
